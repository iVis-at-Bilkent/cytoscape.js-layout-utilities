<!DOCTYPE>
<html>

<head>
  <title>cytoscape-layout-utilities.js demo</title>

  <!--- <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1"> -->

  <script src="https://code.jquery.com/jquery-3.0.0.min.js"></script>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>

  <!-- for testing with local version of cytoscape.js -->
  <!--<script src="../cytoscape.js/build/cytoscape.js"></script>-->
  <script src="https://raw.githack.com/iVis-at-Bilkent/layout-base/unstable/layout-base.js"></script>
  <script src="https://raw.githack.com/iVis-at-Bilkent/cose-base/unstable/cose-base.js"></script>
  <script src="https://raw.githack.com/iVis-at-Bilkent/cytoscape.js-fcose/unstable/cytoscape-fcose.js"></script>
  <script src="https://unpkg.com/cytoscape-graphml/cytoscape-graphml.js"></script>
  <script src="cytoscape-layout-utilities.js"></script>

  <script src="https://unpkg.com/cytoscape-view-utilities/cytoscape-view-utilities.js"></script>
  <style>
    body {
      font-family: helvetica neue, helvetica, liberation sans, arial, sans-serif;
      font-size: 14px;
    }

    .button {
      height: 35px;
      font-size: 16;
      color: brown;
      font-weight: bold;
      cursor: pointer;
    }

    input[type="file"] {
      display: none;
    }

    .custom-file-upload {
      border: 1px solid #ccc;
      display: inline-block;
      padding: 6px 12px;
      cursor: pointer;
    } 

    form {
      display: table;
    }

    p {
      display: table-row;
    }

    label {
      display: table-cell;
      font-size: 14;
    }

    select {
      display: table-cell;
    }

    input {
      display: table-cell;
      margin-left: 5px;
    }

    #cy {
      width: calc((4 * 100% - 154px) / 5);
      height: 95%;
      right: 0%;
      top: 0%;
      float: left;
      overflow: hidden;
      position: fixed;

    }

    .topnav {
      width: 20%;
      background-color: #e9e9e9;
      /* font-weight: bold;*/
      border-color: black;
      border-style: solid;
      font-size: 16;
      padding: 10;
    }

    .topnav b:hover {
      background-color: white;
    }

    /* Customize the label (the container) */
    .topnav .container {

      position: relative;
      padding: 14px;
      cursor: pointer;
      font-size: 15px;
      left: 5px;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* Hide the browser's default radio button */
    .topnav .container input {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }

    /* Create a custom radio button */
    .topnav .checkmark {
      position: absolute;
      top: 17px;
      left: 0;
      right: 0px;
      height: 12px;
      width: 12px;
      margin-right: 20px;
      background-color: #000000;
      border-radius: 50%;
    }

    /* On mouse-over, add a grey background color */
    .container:hover input~.checkmark {
      background-color: #000000;
    }

    /* When the radio button is checked, add a blue background */
    .container input:checked~.checkmark {
      background-color: #000
    }

    /* Create the indicator (the dot/circle - hidden when not checked) */
    .checkmark:after {
      content: "";
      position: absolute;
      display: none;
    }

    /* Show the indicator (dot/circle) when checked */
    .container input:checked~.checkmark:after {
      display: block;
    }

    /* Style the indicator (dot/circle) */
    .container .checkmark:after {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: white;
    }
  </style>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      var cy = window.cy = cytoscape({
        container: document.getElementById('cy'),
        layout: { name: "fcose" },
        style: [
          {
            selector: 'node',
            style: {
              'content': 'data(name)',
              'border-color': function(ele) {
                const { rank = -1 } = ele.scratch('layout_utilities') || {};
                switch (rank) {
                  case -1:
                    return 'grey';
                  case 0:
                    return '#8FE388';
                  case 1:
                    return '#D36135';
                  case 2:
                    return '#279AF1';
                  case 3:
                    return '#89043D';
                  default:
                    return 'black';
                }
              },
              'border-width': 3,
              'background-color': 'lightgrey'
            }
          },
          {
            selector: 'edge',
            style: {
              'target-arrow-shape': 'triangle'
            }
          },
          {
            selector: 'edge:selected',
            style: {
              'line-color': 'orange'
            }
          },
          {
            selector: 'node:selected',
            style: {
              'border-color': 'orange',
              'border-width': '3px',
              'background-color': 'lightgrey'
            }
          },
          {
            selector: 'node:parent',
            style: {
              'background-color': 'lightgrey'
            }
          }
        ],

        elements: {
          nodes: [
            { data: { id: 'n7', name: 'n7' } },
            { data: { id: 'n6', name: 'n6' } },
            { data: { id: 'n5', name: 'n5' } },
            { data: { id: 'n8', name: 'n8' } },
            { data: { id: 'n9', name: 'n9' } },
            { data: { id: 'n10', name: 'n10' } },
            { data: { id: 'n11', name: 'n11' } },
            { data: { id: 'n12', name: 'n12', parent: 'n29' } },
            { data: { id: 'n13', name: 'n13', parent: 'n29' } },
            { data: { id: 'n14', name: 'n14', parent: 'n29' } },
            { data: { id: 'n15', name: 'n15', parent: 'n29' } },
            { data: { id: 'n16', name: 'n16' } },
            { data: { id: 'n17', name: 'n17' } },
            { data: { id: 'n18', name: 'n18' } },
            { data: { id: 'n19', name: 'n19' } },
            { data: { id: 'n20', name: 'n20' } },
            { data: { id: 'n21', name: 'n21' } },
            { data: { id: 'n22', name: 'n22' } },
            { data: { id: 'n23', name: 'n23' } },
            { data: { id: 'n24', name: 'n24' } },
            { data: { id: 'n25', name: 'n25' } },
            { data: { id: 'n26', name: 'n26' } },
            { data: { id: 'n27', name: 'n27' } },
            { data: { id: 'n28', name: 'n28' } },
            { data: { id: 'n29', name: 'n29' } },

          ],
          edges: [
            { data: { source: "n5", target: "n6" } },
            { data: { source: 'n5', target: 'n7' } },
            { data: { source: 'n6', target: 'n7' } },
            { data: { source: "n7", target: "n8" } },
            { data: { source: "n8", target: "n9" } },
            { data: { source: 'n7', target: 'n10' } },
            { data: { source: 'n6', target: 'n11' } },
            { data: { source: "n7", target: "n11" } },
            { data: { source: "n9", target: "n10" } },
            { data: { source: 'n10', target: 'n11' } },
            //{ data: { source: 'n10', target: 'n12' } },
            { data: { source: "n12", target: "n13" } },
            { data: { source: "n12", target: "n14" } },
            { data: { source: "n12", target: "n15" } },
            { data: { source: "n13", target: "n15" } },
            //{ data: { source: 'n15', target: 'n16' } },
            { data: { source: 'n15', target: 'n17' } },
            //{ data: { source: "n15", target: "n18" } },
            { data: { source: "n17", target: "n19" } },
            { data: { source: 'n17', target: 'n20' } },
            { data: { source: 'n19', target: 'n20' } },

            { data: { source: 'n22', target: 'n23' } },
            { data: { source: 'n22', target: 'n24' } },
            { data: { source: 'n24', target: 'n23' } },
            { data: { source: 'n25', target: 'n26' } },
            { data: { source: 'n26', target: 'n27' } },

            //{ data: { source: "n19", target: "n21" } }
          ]
        },
        wheelSensitivity: 0.2
      });

      var api = cy.layoutUtilities(
        {
          desiredAspectRatio: parseFloat($('#desiredAspectRatio').val()),
          polyominoGridSizeFactor: parseFloat($('#gridSizeFactor').val()),
          utilityFunction: parseInt($('#utilityFunctionType').val()),
          componentSpacing: (document.getElementById('auto-spacing').checked ? undefined : parseInt($('#componentSpacing').val())),
          siblingWeight: parseFloat($('#siblingWeight').val())
        }
      );
      var api2 = cy.viewUtilities();

      var layoutOptions = {
        name: 'fcose',
        randomize: false,
        fit: false,
        packComponents: false,
        nodeDimensionsIncludeLabels: true
      };

      function changeBorder(eles) {
        eles.forEach(function (ele) {
          ele.css("background-color", 'purple');
        });
        return eles;
      }
      function revertBorder(eles) {
        eles.forEach(function (ele) {
          ele.css("background-color", 'lightgrey');
        });
        return eles;
      }

      function getTopMostNodes(nodes) {
        let nodesMap = {};
        for (let i = 0; i < nodes.length; i++) {
            nodesMap[nodes[i].id()] = true;
        }
        let roots = nodes.filter(function (ele, i) {
            if(typeof ele === "number") {
              ele = i;
            }
            let parent = ele.parent()[0];
            while(parent != null){
              if(nodesMap[parent.id()]){
                return false;
              }
              parent = parent.parent()[0];
            }
            return true;
        });

        return roots;
      };

      findComponents = function(topMostNodes){
        let queue = [];
        let visited = new Set();
        let visitedTopMostNodes = [];
        let currentNeighbor;

        let allComponentsTraversed = false;
        let components = [];

        do {
          let cmpt = cy.collection();
          components.push(cmpt);

          let currentNode = topMostNodes[0];
          let childrenOfCurrentNode = cy.collection();
          childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants());
          visitedTopMostNodes.push(currentNode);

          childrenOfCurrentNode.forEach(function(node) {
            queue.push(node);
            visited.add(node);
            cmpt.merge(node);
          });

          while(queue.length != 0){
            currentNode = queue.shift();

            // Traverse all neighbors of this node
            let neighborNodes = cy.collection();
            currentNode.neighborhood().nodes().forEach(function(node){
                neighborNodes.merge(node);
            });

            for(let i = 0; i < neighborNodes.length; i++){
              let neighborNode = neighborNodes[i];
              currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));
              if(currentNeighbor != null && !visited.has(currentNeighbor[0])){
                let childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());
                childrenOfNeighbor.forEach(function(node){
                  queue.push(node);
                  visited.add(node);
                  cmpt.merge(node);
                  if(topMostNodes.has(node)){
                    visitedTopMostNodes.push(node);
                  }
                });
              }
            }
          }

          cmpt.forEach(node => {
            node.connectedEdges().forEach(e => { // connectedEdges() usually cached
              if( cmpt.has(e.source()) && cmpt.has(e.target()) ){ // has() is cheap
                cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
              }
            });
          });

          if(visitedTopMostNodes.length == topMostNodes.length){
            allComponentsTraversed = true;
          }

          let temp = cy.collection();
          visitedTopMostNodes.forEach(function(node){
            temp.merge(node);
          });
          visitedTopMostNodes = [];
          topMostNodes = topMostNodes.difference(temp);
        }
        while(!allComponentsTraversed);

        return components;
      };

      $("#polyominoPack").click(function () {
        
        api.setOption("desiredAspectRatio", parseFloat($('#desiredAspectRatio').val()));
        api.setOption("polyominoGridSizeFactor", parseFloat($('#gridSizeFactor').val()));
        api.setOption("utilityFunction", parseInt($('#utilityFunctionType').val()));
        api.setOption("componentSpacing", (document.getElementById('auto-spacing').checked ? undefined : parseInt($('#componentSpacing').val())));
        
        var topMostNodes = getTopMostNodes(cy.nodes());
        var components = findComponents(topMostNodes);
        var subgraphs = [];
        components.forEach(function (component) {
          var subgraph = {};
          subgraph.nodes = [];
          subgraph.edges = [];

          component.edges().forEach(function (edge) {
            subgraph.edges.push({ startX: edge.sourceEndpoint().x, startY: edge.sourceEndpoint().y, endX: edge.targetEndpoint().x, endY: edge.targetEndpoint().y });
          });
          component.nodes().forEach(function (node) {
            var boundingBox = node.boundingBox();
            subgraph.nodes.push({ x: boundingBox.x1, y: boundingBox.y1, width: boundingBox.w, height: boundingBox.h });
          });

          subgraphs.push(subgraph);
        });

        var result = api.packComponents(subgraphs, !document.getElementById('Incremental-checkbox').checked, document.getElementById('spacewise-checkbox').checked);
        $("#resultAspectRatio").text(result.aspectRatio || "-");
        $("#resultFullness").text(result.fullness.toFixed(2) + " %");
        $("#resultAdjustedFullness").text(result.adjustedFullness ? result.adjustedFullness + " %" : "-");
        components.forEach(function (component, index) {
          component.nodes().layout({
            name: 'preset',
            animate: true,
            fit: false,
            transform: (node) => {
              let position = {};
              position.x = node.position('x') + result.shifts[index].dx;
              position.y = node.position('y') + result.shifts[index].dy;
              return position;
            }
          }).run();
        });

      });
      $("#hide").click(function () {
        var nodesWithHiddenNeighbor = cy.edges(":hidden").connectedNodes(':visible');
        api2.hide(cy.$(":selected"));
        nodesWithHiddenNeighbor = cy.edges(":hidden").connectedNodes(':visible');
        changeBorder(nodesWithHiddenNeighbor);
        if (document.getElementById('layout').checked) {
          cy.layout(layoutOptions).run();
        }
      });

      $("#showAll").click(function () {

        api2.show(cy.nodes());
        api2.show(cy.nodes().neighborhood());
        var nodesWithHiddenNeighbor = cy.edges(":hidden").connectedNodes();
        // var hiddenNodes = cy.nodes(":hidden");
        revertBorder(cy.nodes());
        // //api.placeHiddenNodes(nodesWithHiddenNeighbor);
        // api.placeNewNodes(hiddenNodes);
        // api2.show(hiddenNodes);
        if (document.getElementById('layout').checked) {
          cy.layout(layoutOptions).run();
        }
      });

      document.getElementById('siblingWeight').addEventListener('change', function(e) {
        api.setOption("siblingWeight", parseFloat(e.target.value));
      });

      $('#recalculateLayout').click(function() {
        cy.layout(layoutOptions).run();
      })

      $('#performLayout').click(function() {
        cy.layout({...layoutOptions, randomize: true}).run();
      })

      $("#showHiddenNeighbors").click(function () {
        var nodesWithHiddenNeighbor = cy.edges(":hidden").connectedNodes(':visible');
        revertBorder(nodesWithHiddenNeighbor);
        api.placeHiddenNodes(cy.nodes(":selected"));
        api2.show(cy.nodes(":selected").neighborhood());
        revertBorder(cy.nodes());

        nodesWithHiddenNeighbor = cy.edges(":hidden").connectedNodes(':visible');
        changeBorder(nodesWithHiddenNeighbor);
        if (document.getElementById('layout').checked) {
          cy.layout(layoutOptions).run();
        }
      });
      
      // color adjustment functions
      function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      }
      
      function rgbToHex(rgb) {
        return "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
      }
      
      function adjust(color, amount) {
          return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+ Math.min(255, (parseInt(color, 16) + amount + 255) % 255).toString(16)).substr(-2));
      }      
      
      var newNodeCounter = 0;

      function getNewNodes() {
        const nodeCount = parseInt($('#newNodeCount').val());
        const averageDegree = parseInt($('#averageDegree').val());
        const newNodes = cy.collection();
        const currentNodes = cy.nodes();
        const compoundNodes = cy.nodes().filter(e => e.isParent());
        let newCompound;
        for (let nodeId = 0; nodeId < nodeCount; nodeId++) {
          const id = `n${window.iteration}-${nodeId}`;
          const edgeId = `e${window.iteration}-${nodeId}`;
          let parentID;
          switch (Math.ceil(Math.random() * 3)) {
            case 1: // New parent
              if (newNodes.length === 0) {
                newNodes.merge(cy.add({group: 'nodes', data: {id: `${id}a`, name: `${id}a`}}));
              }
              if (!newCompound) {
                const randomNewCompound = newNodes[Math.floor(Math.random() * newNodes.length)];
                newCompound = randomNewCompound;
              }
              parentID = newCompound.id();
              break;
            case 2: // Existing parent
              parentID = compoundNodes[Math.floor(Math.random() * compoundNodes.length)].id()
              break;
            case 3: // No parent
            default:
              break;
          }
          const newNode = cy.add({ group: 'nodes', data: { id, name: id, parent: parentID }});
          newNodes.merge(newNode);

          let neighborCount;
          let selectedNodes = cy.nodes(":selected");
          switch (Math.ceil(Math.random() * 6)) {
            case 1:
              if (selectedNodes.length === 0) {
                neighborCount = 0;
                break;
              }
            case 2:
              neighborCount = 1;
              break;
            default:
              neighborCount = averageDegree;
              break;
          }

          if (neighborCount) {
            const addDummyNodes = function(dummyNodeCount, currentNodes) {
              let nodeToConnect = currentNodes[Math.floor(Math.random() * currentNodes.length)];
              for (let i = 0; i < dummyNodeCount; i++) {
                    // Add necessary dummy nodes
                    const dummyID = `${id}-d${i}`;
                    const dummyNode = cy.add({ group: 'nodes', data: { id: dummyID, name: dummyID}});
                    cy.add({ group: 'edges', data: { id: `${dummyID}-e`, source: nodeToConnect.id(), target: dummyID }})
                    nodeToConnect = dummyNode;
                    newNodes.merge(dummyNode)
                    availableNewNodes.merge(dummyNode)
                  }
            }
            const forbiddenNodes = cy.collection();
            forbiddenNodes.merge(newNode);
            forbiddenNodes.merge(newNode.ancestors());
            forbiddenNodes.merge(newNode.descendants());
            const availableNewNodes = newNodes.difference(forbiddenNodes)
            const availableCurrentNodes = selectedNodes.length > 0 ? selectedNodes : currentNodes.difference(forbiddenNodes)
            const selectedNeighbors = [];

            const randomValue = Math.ceil(Math.random() * 10);
            if (randomValue < 6 && selectedNodes.length === 0) {
              const dummyNodeCount = neighborCount - availableNewNodes.length;
              addDummyNodes(dummyNodeCount, availableCurrentNodes);
              for (let i = 0; i < neighborCount; i++) {
                let randomNeighbor;
                if (i === 0) {
                  // Select the last new node in any case, in order to increase the probability of higher rank nodes
                  randomNeighbor = availableNewNodes[availableNewNodes.length - 1];
                } else {
                  do {
                    randomNeighbor = availableNewNodes[Math.floor(Math.random() * availableNewNodes.length)];
                  } while (selectedNeighbors.includes(randomNeighbor.id()));
                }
                selectedNeighbors.push(randomNeighbor.id());
                cy.add({ group: 'edges', data: { id: `${edgeId}-${i}`, source: id, target: randomNeighbor.id()}})
              }
            } else if (randomValue < 8) {
              const availableCount = Math.min(neighborCount, availableCurrentNodes.length);
              for (let i = 0; i < availableCount; i++) {
                let randomNeighbor;
                do {
                  randomNeighbor = availableCurrentNodes[Math.floor(Math.random() * availableCurrentNodes.length)];
                } while (selectedNeighbors.includes(randomNeighbor.id()));
                selectedNeighbors.push(randomNeighbor.id());
                cy.add({ group: 'edges', data: { id: `${edgeId}-${i}`, source: id, target: randomNeighbor.id()}})
              }
            } else {
              const dummyNodeCount = neighborCount - Math.min(neighborCount / 2, availableCurrentNodes.length) - availableNewNodes.length;
              addDummyNodes(dummyNodeCount, availableCurrentNodes);
              for (let i = 0; i < neighborCount; i++) {
                let randomNeighbor;
                if (i === 0) {
                    // Select the last new node in any case, in order to increase the probability of higher rank nodes
                    randomNeighbor = availableNewNodes[availableNewNodes.length - 1];
                } else {
                  do {
                    let tempNodes;
                    if (i < neighborCount - Math.min(neighborCount / 2, availableCurrentNodes.length)) {
                      tempNodes = availableNewNodes;
                    } else {
                      tempNodes = availableCurrentNodes;
                    }
                    randomNeighbor = tempNodes[Math.floor(Math.random() * tempNodes.length)];
                  } while (selectedNeighbors.includes(randomNeighbor.id()));
                }
                selectedNeighbors.push(randomNeighbor.id());
                cy.add({ group: 'edges', data: { id: `${edgeId}-${i}`, source: id, target: randomNeighbor.id()}})
              }
            }
          }
        }
        return newNodes;
      };
      
      $("#addRandomNeighbors").click(function() {
        window.iteration = (window.iteration || 0) + 1;
        cy.nodes().forEach(node => node.removeScratch());
        const nodes = getNewNodes();
        if (!window.addedElsHistory) window.addedElsHistory = [];
        const els = cy.collection();
        els.merge(nodes);
        els.merge(nodes.connectedEdges());
        window.addedElsHistory.unshift(els);
        window.removedElsHistory = [];
        api.placeNewNodes(nodes);
        if (document.getElementById('layout').checked) {
          cy.layout(layoutOptions).run();
        }
      });

      document.getElementById('load-button')
        .addEventListener('click', () =>{
          document.getElementById('graphml-input').click();
        });

      document.getElementById('graphml-input')
        .addEventListener('change', function (ev) {
          const file = this.files[0];
          if(file){
            cy.elements().remove(); 
            file.text().then((s) => {
              cy.graphml({layoutBy: "fcose"})
              cy.graphml(s);
            });
          }
        });

      document.getElementById('Incremental-checkbox')
        .addEventListener('change', function (ev) {
          const disables = [
            'utilityFunctionType',
            'desiredAspectRatio',
            'gridSizeFactor',
          ];

          const enables = [
            'auto-spacing',
          ];

          for (const disable of disables) {
            document.getElementById(disable).disabled = this.checked;
          }

          for (const enable of enables) {
            document.getElementById(enable).disabled = !this.checked;
            document.getElementById(enable).checked = false;
            document.getElementById(enable).dispatchEvent(new Event('change'));
          }
        });

      document.getElementById('auto-spacing')
        .addEventListener('change', function () {
          document.getElementById('componentSpacing').disabled = this.checked;
        });
    });
  </script>
</head>

<body>
  <h1>cytoscape.js-layout-utilities demo</h1>
  <div class="topnav">
    <label class="custom-file-input" for="graphml-input">
      <button id="load-button" class="button">Load Graphml</button>
    </label>
    <input id="graphml-input" type="file" accept=".graphml">
  </div>
  <div class="topnav">


    <button id="hide" class="button">Hide selected</button>
    <button id="showAll" class="button">Show all</button>
    <br /> <br />
    <button id="recalculateLayout" class="button">Recalculate Layout</button>
    <button id="performLayout" class="button">Perform Layout</button>
    <br /> <br />
    <button id="showHiddenNeighbors" class="button">Show hidden neighbors of selected</button>
    <br /> <br />
    <button id="addRandomNeighbors" class="button">Add random neighbors to selected</button>
    <br /> <br />      

    <form style="margin-bottom: 0px;">
      <p style="position: relative;">
        <label for="layout" style="vertical-align:middle;">
          Rearrange on changes
        </label>
        <input type="checkbox" class="input" id="layout" name="layout" style="vertical-align:middle;" value="checked" checked>
      </p>
      <br/>
      <p>
        <label for="siblingWeight">Sibling Weight</label>
        <input id="siblingWeight" style="width:60px; margin-bottom: 10px!important;" type="number" step="0.25"
          min=".25" value="0.7">
      </p>
      <p>
        <label for="initialNodeCount">Initial Node Count</label>
        <input id="initialNodeCount" style="width:60px; margin-bottom: 10px!important;" type="number" step="5"
          min="5" value="10">
      </p>
      <p>
        <label for="averageDegree">Average Degree</label>
        <input id="averageDegree" style="width:60px; margin-bottom: 10px!important;" type="number" step="1"
          min="0" max="10" value="2">
      </p>
      <p>
        <label for="compoundNodeRatio">Compound Node Ratio</label>
        <input id="compoundNodeRatio" style="width:60px; margin-bottom: 10px!important;" type="number" step="0.1"
          min="0" max="0.5" value="0.1">
      </p>
      <p>
        <label for="averageChildrenCount">Average Children Count</label>
        <input id="averageChildrenCount" style="width:60px; margin-bottom: 10px!important;" type="number" step="1"
          min="0" max="10" value="2">
      </p>
      <p>
        <label for="newNodeCount">New Node Count</label>
        <input id="newNodeCount" style="width:60px; margin-bottom: 10px!important;" type="number" step="1"
          min="0" max="10" value="2">
      </p>
    </form>

    <div style="display: flex;">
      <span style="background-color: #8FE388; width: 16px; height: 16px; margin-right: 10px;"></span>
      <span>Rank 0</span>
    </div>
    <div style="display: flex;">
      <span style="background-color: #D36135; width: 16px; height: 16px; margin-right: 10px;"></span>
      <span>Rank 1</span>
    </div>
    <div style="display: flex;">
      <span style="background-color: #279AF1; width: 16px; height: 16px; margin-right: 10px;"></span>
      <span>Rank 2</span>
    </div>
    <div style="display: flex;">
      <span style="background-color: #89043D; width: 16px; height: 16px; margin-right: 10px;"></span>
      <span>Rank 3</span>
    </div>
    <div style="display: flex;">
      <span style="background-color: #000000; width: 16px; height: 16px; margin-right: 10px;"></span>
      <span>Higher Ranks</span>
    </div>
  </div>
  </div>
  <div class="topnav">

    <button id="polyominoPack" class="button">Pack components</button>
    <br />
    <br />
    <div style="display: flex; align-items: flex-start;">
      <label>Incremental: </label>
      <input id="Incremental-checkbox" type="checkbox" value="bruh">
    </div>
    <br />
    <!-- <input  style="cursor: pointer; color: brown">Pack components</button><br/><br/> -->
    <form>
      <p><label>Select utility function</label></p>
      <p>
        <select id="utilityFunctionType" style="margin-top:10px;">
          <option value="1">Adjusted fullness</option>
          <option value="2"> Weighted fullness and aspect ratio</option>
        </select>
      </p>
    </form>
    <form>
      <p>
        <label for="desiredAspectRatio">Desired aspect ratio</label>
        <input id="desiredAspectRatio" style="width:60px; margin-bottom: 10px!important;" type="number" step="0.25"
          min=".25" value="1">
      </p>
      <p>
        <label for="gridSizeFactor">Polyomino grid size factor</label>
        <input id="gridSizeFactor" style="width:60px; margin-bottom: 10px!important;" type="number" min=".1" value="1"
          step="0.05">
      </p>
      <p>
        <label for="componentSpacing">Component spacing (px)</label>
        <input id="componentSpacing" style="width:60px; margin-bottom: 10px!important; margin-right: 10;" type="number" min="0" value="80"
          step="10">
        <label for="auto-spacing">Auto</label>
        <input type="checkbox" id="auto-spacing" style="vertical-align: middle;" disabled="true">
      </p>


    </form>
    <div>
      <b>Result aspect ratio : <span id=resultAspectRatio style="color:green;">-</span><br /><br />
        <b>Result fullness : <span id=resultFullness style="color:green;"">-</span><br/><br/>
                <b>Result adjusted fullness : <span id=resultAdjustedFullness style="
            color:green;">-</span><br /><br />
    </div>
    <div style="display: flex; align-items: flex-start;">
      <label><span style="font-weight:normal">Consider as Polygons on Calculations</span></label>
      <input id="spacewise-checkbox" type="checkbox" value="bruh">
    </div>
  </div>
  <br>
  <div>
    <b>Shift + drag</b> to specify region<br /><br />
    <!-- <b>Shift + taphold</b> to select neighbors<br/><br/> -->
  </div>

  <div id="cy"></div>

</body>

</html>